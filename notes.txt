ONE DRIVE NOTEBOOK

https://onedrive.live.com/view.aspx?resid=AD7F40F390B59989%2110781&id=documents

############################
LESSON 1 - GETTING SET UP 
############################

https://learn.codeinstitute.net/courses/course-v1:CodeInstitute+FST101+2021_T1/courseware/dc049b343a9b474f8d75822c5fda1582/121ef050096f4546a1c74327a9113ea6/?child=last

Install Django

    * pip3 install django

Create project

    * django-admin startproject my_new_django .

Run project

    * Python3 manage.py runserver




############################
LESSON 2 - URLs
############################

https://learn.codeinstitute.net/courses/course-v1:CodeInstitute+FST101+2021_T1/courseware/dc049b343a9b474f8d75822c5fda1582/685f99dc7b6c41e497b402adbc97dfaa/?child=first


db.sqlite3 is our database for the project. DO NOT DELETE OR CHANGE THIS FILE


Create your app
    * python3 manage.py startapp todo

Give your app content
    Go to views.py in todo folder
    Create function
        
        def say_hello(request):
            return HttpResponse("Hello!")

Make it visible
    Go to urls.py
    import function from views

        from todo.views import say_hello

    Define url to trigger function and return http HttpResponse

        path('hello/', say_hello, name='hello')

View the page

    python3 manage.py run server
    add hello/ to the end of the url
    Hey presto, your broswer is saying hello to you


############################
LESSON 3 - TEMPLATES
############################

https://learn.codeinstitute.net/courses/course-v1:CodeInstitute+FST101+2021_T1/courseware/dc049b343a9b474f8d75822c5fda1582/ed4360267fc348d8b1113b26c7e7511a/?child=first


	• Create templates folder in todo
	• Create todo folder in templates
  	• Create todo_list.html in todo
		○ Set up using ! Tab
		○ Enter some body content
	• Go back to views.py
		○ Render template instead of inserting html directly
			def get_todo_list(request):
			    return render(request, 'todo/todo_list.html')
			
	• Back to urls.py
		○ Update path
			§ path('', get_todo_list, name='get_todo_list')
		○ Change import
			§ from todo.views import get_todo_list
			
	• Settings.py
        Add todo to INSTALLED APPS

run again and your body content will be visible

############################
LESSON 4 - MIGRATIONS AND ADMIN
############################

https://learn.codeinstitute.net/courses/course-v1:CodeInstitute+FST101+2021_T1/courseware/dc049b343a9b474f8d75822c5fda1582/23c1b3c9572a4fc4ad169d67f1ead946/?child=first


When we run our python file at the moment we're getting errors regarding migrations. Let's address that.

	• python3  manage.py makemigrations --dry-run
		○ Shows database changes
		○ Without the fry run bit this helps convert python code to sql code
	• python3 manage.py showmigrations
	• python3 manage.py migrate --plan
		○ That plan is a flag, to see what it will do
		○ Run this without the flag to make the changes

Add a way to log in and look at the tables in our database, and make changes if necessary
	• python3 manage.py createsuperuser
		○ Create username and password
	
Lets login 
	• Go to preview of site
	• Add /admin/ to end of url
    • Enter the details you just created

############################
LESSON 5 - MODELS
############################

https://learn.codeinstitute.net/courses/course-v1:CodeInstitute+FST101+2021_T1/courseware/dc049b343a9b474f8d75822c5fda1582/b0b40af73cf444e88bc2fd4f385c54b8/?child=first

Models are like excel spreadsheets. 

Database = excel spreadsheet
Table = one excel sheet
Common info = sheet headings in first row
Data entries = subsequent rows

You basically need to replicate this with python

CREATE THE MODEL 

	• Go to models.py in todo
		○ Create a class, which is like the sheet name in excel
			    Class Item(models.Model:

		○ Define the attributes that our individual items will have.
			name = models.CharField(max_length=50, null=False, blank=False)
            done = models.BooleanField(null=False, blank=False, default=False)


ADDING DATA

Django uses migrations to handle database operations so lets make a migrations file

	• python3 manage.py makemigrations
		○ This makes a new file (0001_initial.py) which has code to create the database table based on our model.
		So this code will be converted to sequel by Django and executed on the database when we actually run the migrations.
		
	• python3 manage.py showmigrations
		○ This shows an unapplied migration for todo
		
	• python3 manage.py migrate 

We won't be able to see created items in the admin until they're exposed. Let's do that now

	• Register the new models in the todo apps admin.py file
		○ from .models import Item
		○ admin.site.register(Item)

Items is now visible in the todo table, and items can be added.
But the added items aren't named well, so let's change that

	• Go to models.py
		○ Go to item class and add this:
			def __str__(self):
			        return self.name
			
			This overrides the string in the models base class and returns the name we give it instead


############################
LESSON 6 - CREATING DATA
############################

https://learn.codeinstitute.net/courses/course-v1:CodeInstitute+FST101+2021_T1/courseware/dc049b343a9b474f8d75822c5fda1582/0f7b131474fe4ba3a4eec2c159ea463f/?child=first

        ''''''''''''''''''''''''''''''''
          PART 1 - RENDERING DATA PT-1
        ''''''''''''''''''''''''''''''''
    
By now we have a model with items which can be added in the database, but the user cannot see. Let's work on that

	• Go to views.py
		○ Import the Item class from models.py
			 from .models import Item

		○ Update your get_todo_list to query all items in the database
		
			def get_todo_list(request):
			    items = Item.objects.all()
			    context = {
			        'items': items
			    }
			    return render(request, 'todo/todo_list.html', context)
			
	• Go to template file (todo_list.html)
		○ Render your items from the context dictionary
			{{ items }}

                If you check your page now you'll get a very user unfriendly query set.
                A query set is kind of like a list which means we can iterate through it in our template just like we could iterate through a list in Python.

		○ Add a for loop to create a new row for every item in the database and display the name and done status
			
				<table>
			        {% for item in items %}
			            <tr>
			                <td>{{ item.name }}</td>
			                <td>{{ item.done }}</td>
			            </tr>
			        {% endfor %}
                 </table>



        ''''''''''''''''''''''''''''''''
          PART 2 - RENDERING DATA PT-2
        ''''''''''''''''''''''''''''''''

This is editing the table in the template todo_list.html
Let's strike out completed tasks (the if loop) and give the user feedback if the database is empty

    		 <table>
		        {% for item in items %}
		            <tr>
		            {% if item.done %}
		                <td><strike>{{ item.name }}</strike></td>
		            {% else %}
		                <td>{{ item.name }}</td>
		            {% endif %}
		                
		            </tr>
		        {% empty %}
		            <tr><td>You have nothing to do</td></tr>
		        {% endfor %}
            </table>


        ''''''''''''''''''''''''''''''''''''
          PART 3 - CREATING NEW ITEMS PT-1
        ''''''''''''''''''''''''''''''''''''

CRUD time - this handles C and R

We'll give users the option to create new items on the html page

Make a new template for a create new item page and link it up

	• Duplicate html template
	• Rename it add_item.html
		○ Customise the new template as needed
	• Link add_item.html to the todo_list.html page
		○ <a href="/add">Add an item</a>
	• Views.py
		○ Create add_item function
		
			def add_item(request):
			    return render(request, 'todo/add_item.html')
			
	• Urls.py
		○ Add 'add_item' to todo.views import
			§ from todo.views import get_todo_list, add_item
		○ Add 'add_item' to urlpatterns
			§ path('add', add_item, name='add')

Let's add a create button in the new template so users can actually add things

	• Add_item.html
		○ Create form for users to add items



        ''''''''''''''''''''''''''''''''''''
          PART 4 - CREATING NEW ITEMS PT-2
        ''''''''''''''''''''''''''''''''''''


Remember: 
GET retrieves info from server
POST adds to the server
			
Let's add a security step to the top of the form
	• {% csrf_token %}
		○ Csrf = cross-site request forgery token
		○ This is a randomly generated unique value given to the form as a hidden input field when the form is submitted
		○ It ensures the data we're posting is actually coming from our todo list app and not another website
	
	
We need to handle what happens when the user clicks the submit button

	• Views.py
		○ Update the add_item function to handle the post requests.
          It should create a new item as per the input field and bring the user back to the updated todo list.
          This means you need to import redirect from django shortcuts
			
			def add_item(request):
			    if request.method == 'POST':
				        # Get the values entered
			        name = request.POST.get('item_name')
			        done = 'done' in request.POST
			
			        # Create the new object as per the input fields
			        Item.objects.create(name=name, done=done)
			
			        return redirect('get_todo_list')
			
			    return render(request, 'todo/add_item.html')


############################
LESSON 7 - MODIFYING DATA
############################

https://learn.codeinstitute.net/courses/course-v1:CodeInstitute+FST101+2021_T1/courseware/dc049b343a9b474f8d75822c5fda1582/22da66e7007d4b5a9bd53901c84034e8/?child=first

This handles the U D of CRUD

                ''''''''''''''''''''''''''''''''''''
                            PART 1 - FORMS
                ''''''''''''''''''''''''''''''''''''

Django can make and validate forms from the model you provide it.


Set up the template for the form 

	• Make forms.py in main todo directory
	• Set it up as so:

			from django import forms
			from .models import Item
			
			Our form will be a class that inherits a built-in Django class to give it
			some basic functionality.
			
			Set up form by giving it a main class which inherits the functionality of
			ModelForm
			class ItemForm(forms.ModelForm):
			    This inner class tells the form about itself - which fields it should
			    render, how it should display error messages etc.
			    class Meta:
			        model = Item
			        fields = ['name', 'done']
			
	• Off to views.py
		○ Import the ImportForm class
			§ from .forms import ItemForm
		○ Create an instance of the form in add_item
		Create context
Return context to template
			
			def add_item(request):
			    # Our post button is to here, so we need to handle that properly
			    if request.method == 'POST':
			        # this get the value entered into the input field
			        name = request.POST.get('item_name')
			        done = 'done' in request.POST
			
			        # Create the new object as per the input fields
			        Item.objects.create(name=name, done=done)
			
			        # bring the user back to the updated todo list
			        return redirect('get_todo_list')
			    
				# Create instance of form
			    form=ItemForm()
			    context = {
			        'form': form
			    } 
			    return render(request, 'todo/add_item.html', form)

Get rid of the one you made manually and its associated links

	• Now you can delete the form fields in the add_item template
		○ In it's place, render the form with jinja
			<form method="POST" action="add">
			     {% csrf_token %}
			        
			        {{ form }}
			
			        <div>
			            <p>
			                <button type="submit">Add Item</button>
			            </p>
			        </div>
			
			    </form>
		
	• Go back to views.py to change how you read the field values, since we deleted the form
		
		def add_item(request):
		    # Our post button is to here, so we need to handle that properly
		    if request.method == 'POST':
		        form = ItemForm(request.POST)
		        if form.is_valid():
		            form.save()
		        return redirect('get_todo_list')
		

Lets get our form vertical again

	• Add_item.html
		○ Use a built-in django method to change table layout
			§ {{ form.as_p }}





                ''''''''''''''''''''''''''''''''''''
                        PART 2 - EDITING ITEMS
                ''''''''''''''''''''''''''''''''''''


Our todolist.html needs a button to allow users to edit

	• Create that button at the end of each item in the for loop
		<table>
		        {% for item in items %}
		            <tr>
		            {% if item.done %}
		                <td><strike>{{ item.name }}</strike></td>
		            {% else %}
		                <td>{{ item.name }}</td>
		            {% endif %}
					
					# This is the new bit
		            <td>
		                <a href="/edit/{{item.id }}">
		                    <button>Edit</button>
		                </a>
		            </td>
		            
		            </tr>
		        {% empty %}
		        <tr><td>You have nothing to do</td></tr>
		        {% endfor %}
		    </table>

Now the buttons need to go somewhere

	• Views.py
		○ Create edit_item view
			def edit_item(request, item_id):
			    return render(request, 'todo/edit_item.html')
	
	• Duplicate add_item.html and change page for edit_item.html
Here is the form

		<form method="POST">
		        {% csrf_token %}
		        {{ form.as_p }}
		
		        <div>
		            <p>
		                <button type="submit">Update Item</button>
		            </p>
		        </div>
		    </form>
		
	• Urls.py
		○ Add a new path
			§ path('edit/<item_id>', edit_item, name='edit')
			
		○ Import from todo.views
			§ from todo.views import get_todo_list, add_item, edit_item

Our edit button works, but we don't have an edit form yet

	• Views.py
		○ Update your edit_item view
			def edit_item(request, item_id):
			    # Get a copy of the item from the database using a django shortcut
			    # This searches the database for the clicked item, or returns a 404 
			    # error if it doesn't exist
			    item = get_object_or_404(Item, id=item_id)
			
			    # instance=item prepoulates the form with the information we just got 
			    # from the database and stored in the variable item
			    form = ItemForm(instance=item)
			    context = {
			        'form': form
			    }
			
			    return render(request, 'todo/edit_item.html', context)
			
		○ Import get_object_or_404 from shortcuts
			§ from django.shortcuts import render, redirect, get_object_or_404

Our edit form appears but doesn't work because we need a POST handler

	• View.py
		○ Update your edit_item view with if from add_item, adding in the instance
			

			def edit_item(request, item_id):
			    item = get_object_or_404(Item, id=item_id)
			
			    if request.method == 'POST':
			        form = ItemForm(request.POST, instance=item)
			        if form.is_valid():
			            form.save()
			        return redirect('get_todo_list')
			
			    form = ItemForm(instance=item)
			    context = {
			        'form': form
			    }
			
			    return render(request, 'todo/edit_item.html', context)





                ''''''''''''''''''''''''''''''''''''
                  PART 3 - TOGGLING/DELETING ITEMS
                ''''''''''''''''''''''''''''''''''''

############################
LESSON 8 - TESTING
############################

############################
LESSON 9 - DEPLOYMENT
############################